<!--  Adventures in DevOOPS: The Code Crusade
// A browser-based FPS with DevOps humor and arcade-style action

// Import libraries via CDN in HTML
// Three.js, PointerLockControls, and cannon.js are required

// HTML Structure (to be included in your HTML file)
/* -->

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventures in DevOOPS: The Code Crusade</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-size: 20px;
            pointer-events: none;
        }
        #startMenu {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffffff;
        }
        #startMenu h1 {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            font-size: 36px;
        }
        #startButton {
            background-color: #0ff;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: all 0.3s;
        }
        #startButton:hover {
            background-color: #00cccc;
            transform: scale(1.05);
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0ff;
            font-size: 18px;
            text-shadow: 0 0 3px #000;
        }
        #ammo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #0ff;
            font-size: 18px;
            text-shadow: 0 0 3px #000;
        }
        #healthBar {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #0ff;
            margin-top: 5px;
        }
        #healthFill {
            height: 100%;
            background: #0ff;
            width: 100%;
            transition: width 0.3s;
        }
        #scoreDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #0ff;
            font-size: 24px;
            text-shadow: 0 0 3px #000;
        }
        #ultimate {
            position: absolute;
            bottom: 60px;
            right: 20px;
            color: #ff0;
            font-size: 18px;
            text-shadow: 0 0 3px #000;
        }
        #ultimateBar {
            width: 150px;
            height: 15px;
            background: #333;
            border: 2px solid #ff0;
            margin-top: 5px;
        }
        #ultimateFill {
            height: 100%;
            background: #ff0;
            width: 0%;
            transition: width 0.3s;
        }
        #gameOver {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffffff;
        }
        #gameOver h1 {
            color: #f00;
            text-shadow: 0 0 5px #f00;
            font-size: 36px;
        }
        #restartButton {
            background-color: #0ff;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid #0ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: #0ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #waveInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-size: 18px;
            text-shadow: 0 0 3px #000;
        }
        #hitMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            color: red;
            font-size: 24px;
            transform: translate(-50%, -50%);
            display: none;
            pointer-events: none;
        }
        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #0ff;
            font-size: 24px;
            z-index: 1000;
        }
        .loading-bar {
            width: 300px;
            height: 20px;
            background: #333;
            border: 2px solid #0ff;
            margin-top: 20px;
        }
        .loading-fill {
            height: 100%;
            background: #0ff;
            width: 0%;
            transition: width 0.3s;
        }
        #audioControls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            display: flex;
            align-items: center;
            z-index: 100;
        }
        #audioControls input {
            margin-left: 5px;
        }
        .fps-counter {
            position: absolute;
            top: 50px;
            right: 20px;
            color: #0ff;
            font-size: 14px;
            text-shadow: 0 0 3px #000;
        }
        /* Add highscore leaderboard styling */
        #highscoreContainer {
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: #0ff;
            padding: 20px;
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }
        #highscoreContainer.show {
            transform: translateX(0);
        }
        #highscoreTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        #highscoreTable th, #highscoreTable td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #0ff;
        }
        #highscoreTable th {
            background-color: rgba(0, 255, 255, 0.2);
        }
        #nameInputContainer {
            display: none;
            margin-top: 20px;
            text-align: center;
        }
        #nameInput {
            background-color: #222;
            color: #0ff;
            border: 1px solid #0ff;
            padding: 8px;
            width: 200px;
            margin-bottom: 10px;
        }
        #saveScoreButton {
            background-color: #0ff;
            color: #000;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 3px;
        }
        .highscore-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
        }
        .highscore-buttons button {
            background-color: #0ff;
            color: #000;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <h1>Loading Game...</h1>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
    </div>
    <div id="startMenu">
        <h1>Adventures in DevOOPS</h1>
        <h2>The Code Crusade</h2>
        <h2>A game from the mind of E.Ihenacho III</h2>
        <button id="startButton">START GAME</button>
        <p>WASD to move, SPACE to jump, CLICK to shoot</p>
        <p>Press R to reload, F for melee attack</p>
        <p>Press Q to use ultimate ability (when available)</p>
        <p>Press ESC to pause the game</p>
    </div>
    <div id="audioControls">
        <label>Audio: <input type="checkbox" id="audioToggle" checked></label>
    </div>
    <div id="gameOver">
        <h1>SYSTEM FAILURE</h1>
        <p id="finalScore">Score: 0</p>
        <div id="nameInputContainer">
            <p>New high score! Enter your name:</p>
            <input type="text" id="nameInput" maxlength="20" placeholder="Your name">
            <button id="saveScoreButton">Save Score</button>
        </div>
        <button id="restartButton">RESTART</button>
        <button id="viewHighscoresButton" style="margin-top: 10px; background-color: #0ff; color: #000; border: none; padding: 15px 30px; font-size: 20px; cursor: pointer; border-radius: 5px;">VIEW HIGHSCORES</button>
    </div>
    <div id="highscoreContainer">
        <h2>HIGHSCORES</h2>
        <table id="highscoreTable">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Name</th>
                    <th>Score</th>
                    <th>Date</th>
                </tr>
            </thead>
            <tbody id="highscoreTableBody">
                <!-- Highscores will be inserted here -->
            </tbody>
        </table>
        <div class="highscore-buttons">
            <button id="exportHighscores">Export CSV</button>
            <button id="importHighscores">Import CSV</button>
            <button id="closeHighscores">Close</button>
        </div>
        <input type="file" id="importFile" accept=".csv" style="display: none;">
    </div>
    <div class="crosshair"></div>
    <div id="hitMarker">âœ“</div>
    <div id="scoreDisplay">Score: 0</div>
    <div id="waveInfo">Wave: 1</div>
    <div id="hud">
        <div>Server Uptime: <span id="health">100</span>%</div>
        <div id="healthBar"><div id="healthFill"></div></div>
    </div>
    <div id="ammo">
        <div>Bandwidth: <span id="ammoCount">30</span> / <span id="maxAmmo">30</span></div>
    </div>
    <div id="ultimate">
        <div>K8s Cluster Bomb: <span id="ultimateStatus">Charging</span></div>
        <div id="ultimateBar"><div id="ultimateFill"></div></div>
    </div>
    <div class="fps-counter" id="fpsCounter">FPS: 60</div>
    <audio id="backgroundMusic" loop></audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="highscore.js"></script>
    <script>
        // Main game code starts here
        document.addEventListener('DOMContentLoaded', function() {
            // Show loading screen
            const loadingScreen = document.getElementById('loadingScreen');
            const loadingFill = document.getElementById('loadingFill');
            const fpsCounter = document.getElementById('fpsCounter');
            const audioToggle = document.getElementById('audioToggle');
            
            let loadingProgress = 0;
            const loadingInterval = setInterval(() => {
                loadingProgress += 5;
                loadingFill.style.width = loadingProgress + '%';
                if (loadingProgress >= 100) {
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }
            }, 100);
            
            // Mute/unmute audio
            let audioEnabled = true;
            
            audioToggle.addEventListener('change', function() {
                audioEnabled = this.checked;
                
                // Update all audio elements
                backgroundMusic.muted = !audioEnabled;
                Object.values(sounds).forEach(sound => {
                    sound.muted = !audioEnabled;
                });
                
                // Save preference
                localStorage.setItem('audioEnabled', audioEnabled);
            });
            
            // Load saved audio preference
            if (localStorage.getItem('audioEnabled') === 'false') {
                audioEnabled = false;
                audioToggle.checked = false;
            }

            // Game configuration
            const config = {
                playerHealth: 100,
                playerSpeed: 6, // Adjusted for better movement feel
                jumpForce: 8,
                gravity: -9.8 * 5,
                ammo: 30,
                maxAmmo: 30,
                reloadTime: 2,
                meleeCooldown: 600, // milliseconds
                ultimateChargeMax: 100,
                ultimateCharge: 0,
                bulletDamage: 20,
                meleeDamage: 40,
                ultimateDamage: 100,
                ultimateRadius: 20,
                enemySpawnRadius: 40,
                enemyCount: 0,
                maxEnemies: 10,
                wave: 1,
                score: 0,
                killsPerWave: 10,
                enemiesKilled: 0,
                bulletSpeed: 40, // Increase bullet speed for better aiming
                bulletLifetime: 5, // How long bullets exist in seconds
                enemyHealth: 100,
                enemySpawnRate: 2, // Time in seconds between enemy spawns
                enemySpawnLimit: 20, // Maximum number of enemies at once
                gameTime: 300, // 5 minutes in seconds
                scoreForKill: 100,
                mouseSensitivity: 0.2 // Add mouse sensitivity config
            };

            // Audio configuration
            const sounds = {
                shoot: new Audio('https://assets.mixkit.co/active_storage/sfx/212/212-preview.mp3'),
                reload: new Audio('https://assets.mixkit.co/active_storage/sfx/2020/2020-preview.mp3'),
                melee: new Audio('https://assets.mixkit.co/active_storage/sfx/2018/2018-preview.mp3'),
                hit: new Audio('https://assets.mixkit.co/active_storage/sfx/235/235-preview.mp3'),
                enemyDie: new Audio('https://assets.mixkit.co/active_storage/sfx/156/156-preview.mp3'),
                playerHit: new Audio('https://assets.mixkit.co/active_storage/sfx/209/209-preview.mp3'),
                ultimate: new Audio('https://assets.mixkit.co/active_storage/sfx/557/557-preview.mp3'),
                powerup: new Audio('https://assets.mixkit.co/active_storage/sfx/270/270-preview.mp3'),
                gameOver: new Audio('https://assets.mixkit.co/active_storage/sfx/217/217-preview.mp3')
            };

            // Background music 
            const backgroundMusic = document.getElementById('backgroundMusic');
            backgroundMusic.src = "DarkVibes.mp3"; // Placeholder URL, replace with your music file
            backgroundMusic.volume = 0.4;
            
            // Handle audio loading errors
            backgroundMusic.addEventListener('error', function() {
                console.warn("Error loading background music. Using fallback.");
                this.src = "https://assets.mixkit.co/active_storage/sfx/218/218-preview.mp3"; // Fallback soundtrack
            });

            // Set up volume for sound effects and add error handling
            Object.values(sounds).forEach(sound => {
                sound.volume = 0.3;
                sound.addEventListener('error', function() {
                    console.warn("Error loading sound effect:", this.src);
                });
            });

            // Initialize Three.js scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Dark blue background
            scene.fog = new THREE.Fog(0x050510, 10, 100);

            // Set up camera
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);

            // Set up renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Add neon lights for atmosphere
            const bluePointLight = new THREE.PointLight(0x00ffff, 1, 20);
            bluePointLight.position.set(10, 5, 10);
            scene.add(bluePointLight);

            const purplePointLight = new THREE.PointLight(0xff00ff, 1, 20);
            purplePointLight.position.set(-10, 5, -10);
            scene.add(purplePointLight);

            // Set up physics world
            const world = new CANNON.World();
            world.gravity.set(0, config.gravity, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Materials
            const physicsMaterial = new CANNON.Material("groundMaterial");
            const playerPhysicsMaterial = new CANNON.Material("playerMaterial");

            const playerGroundContact = new CANNON.ContactMaterial(
                playerPhysicsMaterial,
                physicsMaterial,
                { friction: 0.5, restitution: 0.3 }
            );
            world.addContactMaterial(playerGroundContact);

            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Floor physics
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({
                mass: 0,
                material: physicsMaterial
            });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(floorBody);

            // Player setup
            const controls = new THREE.PointerLockControls(camera, document.body);
            let playerBody;
            let canJump = false;
            let isReloading = false;
            let isMeleeCooldown = false;
            let canUseUltimate = false;

            // Initialize player physics body
            function initPlayer() {
                const playerShape = new CANNON.Sphere(1);
                playerBody = new CANNON.Body({
                    mass: 5,
                    material: playerPhysicsMaterial,
                    position: new CANNON.Vec3(0, 2, 0),
                    linearDamping: 0.9
                });
                playerBody.addShape(playerShape);
                world.addBody(playerBody);

                // Contact event to detect when player is on ground
                playerBody.addEventListener('collide', function(e) {
                    const contact = e.contact;
                    const normalVelocity = contact.getImpactVelocityAlongNormal();

                    // Check if contact is on the bottom of the player and the normal velocity is significant
                    if (contact.ni.y > 0.5 && normalVelocity < 0) {
                        canJump = true;
                    }
                });
            }

            // Game state
            let isGameActive = false;
            let gameOver = false;
            const enemies = [];
            const bullets = [];
            const powerUps = [];
            const keys = {};
            let lastTime = performance.now();

            // UI elements
            const healthDisplay = document.getElementById('health');
            const healthFill = document.getElementById('healthFill');
            const ammoDisplay = document.getElementById('ammoCount');
            const maxAmmoDisplay = document.getElementById('maxAmmo');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const ultimateStatus = document.getElementById('ultimateStatus');
            const ultimateFill = document.getElementById('ultimateFill');
            const waveInfo = document.getElementById('waveInfo');
            const startMenu = document.getElementById('startMenu');
            const startButton = document.getElementById('startButton');
            const gameOverScreen = document.getElementById('gameOver');
            const restartButton = document.getElementById('restartButton');
            const finalScore = document.getElementById('finalScore');
            const hitMarker = document.getElementById('hitMarker');

            // Movement vectors
            const movement = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                jump: false
            };

            // Event listeners are now set up in the init function
            
            // Controls lock change handler
            controls.addEventListener('lock', function() {
                if (!gameOver) {
                    isGameActive = true;
                }
            });

            controls.addEventListener('unlock', function() {
                if (isGameActive && !gameOver) {
                    // Game is paused
                }
            });

            // Track FPS
            let frameCount = 0;
            let lastFpsUpdate = 0;
            
            function updateFPS() {
                frameCount++;
                const now = performance.now();
                
                if (now - lastFpsUpdate >= 1000) { // Update once per second
                    const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                    fpsCounter.textContent = `FPS: ${fps}`;
                    frameCount = 0;
                    lastFpsUpdate = now;
                }
            }

            // Audio play function with error handling
            function playSound(sound) {
                if (!audioEnabled) return;
                
                try {
                    // Reset sound to beginning if it's already playing
                    sound.currentTime = 0;
                    sound.play().catch(e => {
                        console.warn("Error playing sound:", e);
                    });
                } catch (e) {
                    console.warn("Error playing sound:", e);
                }
            }
            
            // Background music play function
            function playMusic() {
                if (!audioEnabled) return;
                
                try {
                    backgroundMusic.play().catch(e => {
                        console.warn("Unable to autoplay music. User interaction needed:", e);
                    });
                } catch (e) {
                    console.warn("Error playing music:", e);
                }
            }

            // Start the game
            function startGame() {
                console.log("Starting game...");
                startMenu.style.display = 'none';
                
                // Reset game state for clean start
                config.wave = 1;
                config.killsPerWave = 10;
                config.maxEnemies = 10;
                config.playerHealth = 100;
                config.ammo = config.maxAmmo;
                config.score = 0;
                
                // Update UI
                healthDisplay.textContent = config.playerHealth;
                healthFill.style.width = config.playerHealth + '%';
                ammoDisplay.textContent = config.ammo;
                scoreDisplay.textContent = 'Score: ' + config.score;
                waveInfo.textContent = 'Wave: ' + config.wave;
                
                initPlayer();
                controls.lock();
                playMusic();
                isGameActive = true;
                gameOver = false;
                
                // Clear all existing objects for clean start
                while (enemies.length > 0) {
                    removeEnemy(enemies[0]);
                }
                
                while (bullets.length > 0) {
                    removeBullet(bullets[0]);
                }
                
                while (powerUps.length > 0) {
                    removePowerUp(powerUps[0]);
                }
                
                spawnServerRacks();
                spawnEnemyWave(); // Spawn initial wave
                
                // Reset time for delta calculation
                lastTime = performance.now();
                
                // Start animation loop
                animate();
                
                console.log("Game started successfully");
            }

            // Restart the game
            function restartGame() {
                // When player enters name, store it for next time
                if (nameInput.value.trim()) {
                    localStorage.setItem('playerName', nameInput.value.trim());
                }
                
                // Hide name input
                nameInputContainer.style.display = 'none';
                
                // Hide highscore container
                highscoreContainer.classList.remove('show');
                
                // Reset game configuration
                config.playerHealth = 100;
                config.ammo = config.maxAmmo;
                config.ultimateCharge = 0;
                config.wave = 1;
                config.score = 0;
                config.enemiesKilled = 0;

                // Update UI
                healthDisplay.textContent = config.playerHealth;
                healthFill.style.width = config.playerHealth + '%';
                ammoDisplay.textContent = config.ammo;
                scoreDisplay.textContent = 'Score: ' + config.score;
                ultimateStatus.textContent = 'Charging';
                ultimateFill.style.width = '0%';
                waveInfo.textContent = 'Wave: ' + config.wave;

                // Reset player position
                playerBody.position.set(0, 2, 0);
                playerBody.velocity.set(0, 0, 0);

                // Clear all enemies, bullets, and powerups
                while (enemies.length > 0) {
                    removeEnemy(enemies[0]);
                }

                while (bullets.length > 0) {
                    removeBullet(bullets[0]);
                }

                while (powerUps.length > 0) {
                    removePowerUp(powerUps[0]);
                }

                // Hide game over screen
                gameOverScreen.style.display = 'none';

                // Lock controls and activate game
                controls.lock();
                isGameActive = true;
                gameOver = false;

                // Restart background music
                backgroundMusic.currentTime = 0;
                try {
                    backgroundMusic.play().catch(e => {
                        console.warn("Error restarting music:", e);
                    });
                } catch (e) {
                    console.warn("Error restarting music:", e);
                }
            }

            // Create environment (server room with server racks)
            function createEnvironment() {
                // Create server room walls
                const wallMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333344,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const gridHelper = new THREE.GridHelper(100, 50, 0x0088ff, 0x0044aa);
                scene.add(gridHelper);

                // Add walls
                const wallGeometry = new THREE.BoxGeometry(100, 10, 1);
                const walls = [
                    { position: [0, 5, 50], rotation: [0, 0, 0] },
                    { position: [0, 5, -50], rotation: [0, 0, 0] },
                    { position: [50, 5, 0], rotation: [0, Math.PI / 2, 0] },
                    { position: [-50, 5, 0], rotation: [0, Math.PI / 2, 0] }
                ];
                walls.forEach(wall => {
                    const mesh = new THREE.Mesh(wallGeometry, wallMaterial);
                    mesh.position.set(...wall.position);
                    mesh.rotation.set(...wall.rotation);
                    scene.add(mesh);
                    // Add physics body for wall
                    const wallShape = new CANNON.Box(new CANNON.Vec3(50, 5, 0.5));
                    const wallBody = new CANNON.Body({ mass: 0, material: physicsMaterial });
                    wallBody.addShape(wallShape);
                    wallBody.position.set(...wall.position);
                    wallBody.quaternion.setFromEuler(...wall.rotation);
                    world.addBody(wallBody);
                });

                // Add some cool neon lights to the ceiling
                const ceilingLights = [];
                for (let i = -40; i <= 40; i += 20) {
                    for (let j = -40; j <= 40; j += 20) {
                        const light = new THREE.PointLight(0x00ccff, 0.7, 15);
                        light.position.set(i, 9, j);
                        scene.add(light);
                        ceilingLights.push(light);
                        // Add light fixture mesh
                        const lightFixtureGeometry = new THREE.BoxGeometry(1, 0.2, 1);
                        const lightFixtureMaterial = new THREE.MeshStandardMaterial({ color: 0x00ccff, emissive: 0x00ccff, emissiveIntensity: 0.5 });
                        const lightFixture = new THREE.Mesh(lightFixtureGeometry, lightFixtureMaterial);
                        lightFixture.position.set(i, 9, j);
                        scene.add(lightFixture);
                    }
                }
            }

            // Spawn server racks as obstacles
            function spawnServerRacks() {
                const rackGeometry = new THREE.BoxGeometry(2, 4, 6);
                const rackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.7 });
                const rackPositions = [
                    { x: 10, z: 10 }, { x: -10, z: 10 }, { x: 10, z: -10 }, { x: -10, z: -10 },
                    { x: 20, z: 20 }, { x: -20, z: 20 }, { x: 20, z: -20 }, { x: -20, z: -20 },
                    { x: 0, z: 20 }, { x: 0, z: -20 }, { x: 20, z: 0 }, { x: -20, z: 0 }
                ];
                rackPositions.forEach(position => {
                    // Create a server rack with blinking lights
                    const rack = new THREE.Group();
                    // Main rack
                    const mainRack = new THREE.Mesh(rackGeometry, rackMaterial);
                    rack.add(mainRack);
                    // Add blinking lights
                    for (let i = 0; i < 5; i++) {
                        const lightGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                        const lightColor = Math.random() > 0.5 ? 0x00ff00 : 0xff0000;
                        const lightMaterial = new THREE.MeshBasicMaterial({ color: lightColor, emissive: lightColor, emissiveIntensity: 1 });
                        const light = new THREE.Mesh(lightGeometry, lightMaterial);
                        light.position.set(0.9, i * 0.7 - 1.5, -2.5);
                        rack.add(light);
                        // Add point light for glow effect
                        const pointLight = new THREE.PointLight(lightColor, 0.5, 3);
                        pointLight.position.copy(light.position);
                        rack.add(pointLight);
                    }
                    // Position the rack
                    rack.position.set(position.x, 2, position.z);
                    // Random rotation
                    rack.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(rack);
                    // Add physics body for the rack
                    const rackShape = new CANNON.Box(new CANNON.Vec3(1, 2, 3));
                    const rackBody = new CANNON.Body({ mass: 0, material: physicsMaterial });
                    rackBody.addShape(rackShape);
                    rackBody.position.set(position.x, 2, position.z);
                    rackBody.quaternion.setFromEuler(0, rack.rotation.y, 0);
                    world.addBody(rackBody);
                });
            }

            // Enemy types
            const enemyTypes = [
                {
                    name: "Buffer Overflow Beetle",
                    health: 40,
                    speed: 3,
                    damage: 10,
                    color: 0xff5500,
                    scale: 1,
                    scoreValue: 100,
                    onDeath: function(enemy) {
                        // Spawn smaller bugs on death
                        if (enemy.scale === 1) {
                            for (let i = 0; i < 2; i++) {
                                spawnSmallBug(enemy.mesh.position.x, enemy.mesh.position.z);
                            }
                        }
                    }
                },
                {
                    name: "SQL Injection Slug",
                    health: 30,
                    speed: 2,
                    damage: 5,
                    color: 0x00ff00,
                    scale: 0.8,
                    scoreValue: 150,
                    update: function(enemy, delta) {
                        // Leave toxic trail
                        if (Math.random() < 0.05) {
                            createToxicTrail(enemy.mesh.position.x, enemy.mesh.position.z);
                        }
                    }
                },
                {
                    name: "404 Zombie",
                    health: 25,
                    speed: 2.5,
                    damage: 8,
                    color: 0x888888,
                    scale: 1.2,
                    scoreValue: 120
                },
                {
                    name: "DDoS Droid",
                    health: 60,
                    speed: 4,
                    damage: 15,
                    color: 0x00ffff,
                    scale: 1.5,
                    scoreValue: 200,
                    attackPattern: "charge", // Special attack pattern
                    chargeSpeed: 8,
                    isCharging: false,
                    chargeTarget: null,
                    chargeTimer: 0,
                    onDeath: function(enemy) {
                      // Drop a powerup on death
                      spawnPowerUp(enemy.mesh.position.x, enemy.mesh.position.z);
                    },
                    update: function(enemy, delta) {
                        if (this.isCharging) {
                            this.chargeTimer -= delta;
                            if (this.chargeTimer <= 0) {
                                this.isCharging = false;
                                this.chargeTimer = 0;
                                this.chargeTarget = null;
                                this.speed = this.speed / 2; // Revert to normal speed
                            }
                            // Move towards player
                            if (this.chargeTarget) {
                                const direction = new THREE.Vector3();
                                direction.subVectors(playerBody.position, enemy.mesh.position);
                                direction.normalize();
                                enemy.body.velocity.x = direction.x * this.chargeSpeed;
                                enemy.body.velocity.z = direction.z * this.chargeSpeed;
                            }
                        } else {
                            if (Math.random() < 0.02) { // 2% chance per frame to start charging
                                this.isCharging = true;
                                this.chargeTimer = 2000; // Charge for 2 seconds
                                this.chargeTarget = playerBody.position.clone();
                                this.speed = this.chargeSpeed; // Double speed when charging.
                            }
                        }
                    }
                }
            ];

            // Function to spawn a small bug
            function spawnSmallBug(x, z) {
                const bugType = enemyTypes.find(type => type.name === "Buffer Overflow Beetle");
                if (!bugType) return;

                const enemy = {
                    type: bugType,
                    health: bugType.health * 0.5, // Half health
                    speed: bugType.speed * 1.5, // 1.5x speed
                    damage: bugType.damage * 0.5, // Half damage
                    mesh: createEnemyMesh(bugType.color, 0.5), // Half size
                    body: createEnemyPhysicsBody(x, 1, z, 0.5),
                    scale: 0.5,
                    isAlive: true
                };
                enemy.mesh.position.set(x, 1, z);
                scene.add(enemy.mesh);
                world.addBody(enemy.body);
                enemies.push(enemy);
                config.enemyCount++;
            }

            // Function to create a toxic trail
            function createToxicTrail(x, z) {
                const trailGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const trailMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 });
                const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                trailMesh.position.set(x, 0.1, z);
                scene.add(trailMesh);

                // Add to an array for disposal later
                setTimeout(() => {
                    scene.remove(trailMesh);
                }, 2000); // Remove after 2 seconds
            }

            // Function to spawn an enemy
            function spawnEnemy() {
                // Safety check
                if (!playerBody || !isGameActive) return null;
                
                // Enemy limit check
                if (enemies.length >= config.maxEnemies) return null;

                try {
                    // Choose a random enemy type
                    const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    
                    // Calculate spawn position (random angle around player)
                    const angle = Math.random() * Math.PI * 2;
                    const spawnRadius = config.enemySpawnRadius * (0.8 + Math.random() * 0.4); // Add some variation
                    const x = playerBody.position.x + Math.cos(angle) * spawnRadius;
                    const z = playerBody.position.z + Math.sin(angle) * spawnRadius;
                    
                    // Make sure spawn position is valid
                    if (isNaN(x) || isNaN(z)) {
                        console.error("Invalid spawn coordinates");
                        return null;
                    }

                    // Check if the enemy would spawn inside a server rack
                    let isInsideRack = false;
                    for (const rack of scene.children) {
                        if (rack.type === 'Group') { // Server racks are groups
                            const rackX = rack.position.x;
                            const rackZ = rack.position.z;
                            const distance = Math.sqrt(Math.pow(x - rackX, 2) + Math.pow(z - rackZ, 2));
                            if (distance < 5) { // If within 5 units of a rack
                                isInsideRack = true;
                                break;
                            }
                        }
                    }

                    if (isInsideRack) {
                        // Try again with a different position
                        return spawnEnemy();
                    }

                    // Create the enemy mesh and physics body
                    const mesh = createEnemyMesh(enemyType.color, enemyType.scale);
                    const body = createEnemyPhysicsBody(x, 1, z, enemyType.scale);
                    
                    // Create the enemy object
                    const enemy = {
                        type: enemyType,
                        health: enemyType.health,
                        speed: enemyType.speed,
                        damage: enemyType.damage,
                        mesh: mesh,
                        body: body,
                        scale: enemyType.scale,
                        isAlive: true,
                        lastAttack: 0
                    };
                    
                    // Position the mesh
                    enemy.mesh.position.set(x, 1, z);
                    
                    // Add to scene and physics world
                    scene.add(enemy.mesh);
                    world.addBody(enemy.body);
                    
                    // Add to enemy array
                    enemies.push(enemy);
                    config.enemyCount++;
                    
                    return enemy;
                } catch (e) {
                    console.error("Error in spawnEnemy:", e);
                    return null;
                }
            }
            
            // This is a guaranteed spawner for initial waves
            function forceSpawnEnemy() {
                // Try multiple times if needed
                for (let attempts = 0; attempts < 5; attempts++) {
                    const enemy = spawnEnemy();
                    if (enemy) return enemy;
                }
                
                // If all spawn attempts failed, create at an absolute position
                try {
                    const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    const x = 15; // Fixed position away from racks
                    const z = 15;
                    
                    const mesh = createEnemyMesh(enemyType.color, enemyType.scale);
                    const body = createEnemyPhysicsBody(x, 1, z, enemyType.scale);
                    
                    const enemy = {
                        type: enemyType,
                        health: enemyType.health,
                        speed: enemyType.speed,
                        damage: enemyType.damage,
                        mesh: mesh,
                        body: body,
                        scale: enemyType.scale,
                        isAlive: true,
                        lastAttack: 0
                    };
                    
                    enemy.mesh.position.set(x, 1, z);
                    scene.add(enemy.mesh);
                    world.addBody(enemy.body);
                    enemies.push(enemy);
                    config.enemyCount++;
                    
                    return enemy;
                } catch (e) {
                    console.error("Error in force spawn:", e);
                    return null;
                }
            }
            
            // Function to spawn a wave of enemies
            function spawnEnemyWave() {
                // Calculate number of enemies to spawn based on wave
                const baseSpawn = 3 + Math.floor(config.wave / 2);
                const enemiesToSpawn = Math.min(baseSpawn, 10); // Cap at 10 at once
                
                console.log("Spawning new wave with " + enemiesToSpawn + " enemies");
                
                // Guaranteed minimum number of enemies for the wave
                for (let i = 0; i < enemiesToSpawn; i++) {
                    setTimeout(() => {
                        try {
                            forceSpawnEnemy();
                        } catch (e) {
                            console.error("Error spawning enemy in wave:", e);
                        }
                    }, i * 300); // Staggered spawn timing
                }
                
                // For higher waves, add a second spawn group after a delay
                if (config.wave > 1) {
                    setTimeout(() => {
                        const secondSpawn = Math.floor(enemiesToSpawn / 2);
                        console.log("Spawning second group with " + secondSpawn + " enemies");
                        
                        for (let i = 0; i < secondSpawn; i++) {
                            setTimeout(() => {
                                try {
                                    if (enemies.length < config.maxEnemies) {
                                        forceSpawnEnemy();
                                    }
                                } catch (e) {
                                    console.error("Error spawning additional enemy:", e);
                                }
                            }, i * 400);
                        }
                    }, enemiesToSpawn * 300 + 1500); // Wait after first group
                }
                
                // Set up a periodic check to ensure enemies are spawning correctly
                const waveCheck = setInterval(() => {
                    // If no enemies and still have kills to go, force spawn some
                    if (enemies.length === 0 && config.killsPerWave > 0 && isGameActive && !gameOver) {
                        console.log("No enemies detected, forcing spawns...");
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                try {
                                    forceSpawnEnemy();
                                } catch (e) {
                                    console.error("Error in periodic spawn:", e);
                                }
                            }, i * 200);
                        }
                    }
                    
                    // If wave completed or game over, stop checking
                    if (config.killsPerWave <= 0 || !isGameActive || gameOver) {
                        clearInterval(waveCheck);
                    }
                }, 5000); // Check every 5 seconds
            }

            // Bullet logic
            function createBullet(x, y, z, direction) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                
                // Add point light to bullet for glow effect
                const bulletLight = new THREE.PointLight(0xffff00, 0.5, 2);
                mesh.add(bulletLight);
                
                const body = new CANNON.Body({
                    mass: 1,
                    position: new CANNON.Vec3(x, y, z),
                    linearDamping: 0,
                    shape: new CANNON.Sphere(0.1)
                });
                
                body.velocity.set(
                    direction.x * config.bulletSpeed, 
                    direction.y * config.bulletSpeed, 
                    direction.z * config.bulletSpeed
                );
                
                world.addBody(body);
                
                // Set lifetime for bullet to avoid memory leaks
                const bulletObj = { 
                    mesh, 
                    body, 
                    isAlive: true,
                    created: Date.now()
                };
                
                return bulletObj;
            }

            // Function to remove bullet
            function removeBullet(bullet) {
                if (!bullet) return;
                
                try {
                    // Remove from scene
                    if (bullet.mesh) {
                        if (bullet.mesh.children.length > 0) {
                            // Remove any lights attached to the bullet
                            for (let i = bullet.mesh.children.length - 1; i >= 0; i--) {
                                bullet.mesh.remove(bullet.mesh.children[i]);
                            }
                        }
                        scene.remove(bullet.mesh);
                    }
                    
                    // Remove from physics world
                    if (bullet.body) {
                        bullet.body.position.set(0, -1000, 0); // Move far away before removal
                        world.removeBody(bullet.body);
                    }
                    
                    // Remove from array
                    const index = bullets.indexOf(bullet);
                    if (index > -1) {
                        bullets.splice(index, 1);
                    }
                } catch (e) {
                    console.error("Error removing bullet:", e);
                }
            }

            // Power-up types
            const powerUpTypes = [
                {
                    name: "Health Pack",
                    color: 0x00ff00,
                    onPickup: function(player) {
                        config.playerHealth = Math.min(config.playerHealth + 20, 100);
                        healthDisplay.textContent = config.playerHealth;
                        healthFill.style.width = config.playerHealth + '%';
                        playSound(sounds.powerup);
                    }
                },
                {
                    name: "Ammo Refill",
                    color: 0x00ffff,
                    onPickup: function(player) {
                        config.ammo = config.maxAmmo;
                        ammoDisplay.textContent = config.ammo + ' / ' + config.maxAmmo;
                        playSound(sounds.powerup);
                    }
                },
                {
                  name: "Ultimate Charge",
                  color: 0xffa500, // Orange
                  onPickup: function(player) {
                    config.ultimateCharge = Math.min(config.ultimateCharge + 30, config.ultimateChargeMax); // Give 30% charge
                    updateUltimateUI();
                    playSound(sounds.powerup);
                  }
                }
            ];

            // Function to spawn a power-up
            function spawnPowerUp(x, z) {
                const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
                const material = new THREE.MeshBasicMaterial({ color: powerUpType.color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, 0.5, z);
                scene.add(mesh);
                const powerUp = {
                    type: powerUpType,
                    mesh: mesh,
                    isAlive: true
                };
                powerUps.push(powerUp);
            }

            // Function to remove power-up
            function removePowerUp(powerUp) {
                if (!powerUp) return;
                scene.remove(powerUp.mesh);
                const index = powerUps.indexOf(powerUp);
                if (index > -1) {
                    powerUps.splice(index, 1);
                }
            }

            // Function to handle player-powerup collision
            function handlePowerUpCollision(playerBody, powerUp) {
              if (!powerUp.isAlive) return;

              const playerPos = new THREE.Vector3(playerBody.position.x, playerBody.position.y, playerBody.position.z);
              const powerUpPos = powerUp.mesh.position;
              const distance = playerPos.distanceTo(powerUpPos);

              if (distance < 1.5) { // If player is close enough
                  powerUp.type.onPickup(playerBody); // Apply power-up effect
                  removePowerUp(powerUp); // Remove power-up from scene
              }
            }

            // Function to update ultimate UI
            function updateUltimateUI() {
                ultimateFill.style.width = (config.ultimateCharge / config.ultimateChargeMax) * 100 + '%';
                if (config.ultimateCharge >= config.ultimateChargeMax) {
                    canUseUltimate = true;
                    ultimateStatus.textContent = 'READY!';
                } else {
                    canUseUltimate = false;
                    ultimateStatus.textContent = 'Charging';
                }
            }

            // Highscore system
            const highscoreContainer = document.getElementById('highscoreContainer');
            const highscoreTableBody = document.getElementById('highscoreTableBody');
            const nameInputContainer = document.getElementById('nameInputContainer');
            const nameInput = document.getElementById('nameInput');
            const saveScoreButton = document.getElementById('saveScoreButton');
            const viewHighscoresButton = document.getElementById('viewHighscoresButton');
            const closeHighscoresButton = document.getElementById('closeHighscores');
            const exportHighscoresButton = document.getElementById('exportHighscores');
            const importHighscoresButton = document.getElementById('importHighscores');
            const importFileInput = document.getElementById('importFile');
            
            let currentScore = 0;
            const highscoreManager = new HighscoreManager(10); // Keep top 10 scores
            
            // Display highscores in table
            function displayHighscores() {
                // Clear existing rows
                highscoreTableBody.innerHTML = '';
                
                // Get current highscores
                const scores = highscoreManager.getHighscores();
                
                // Add each highscore as a row
                scores.forEach((entry, index) => {
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${entry.name}</td>
                        <td>${entry.score}</td>
                        <td>${entry.date}</td>
                    `;
                    
                    highscoreTableBody.appendChild(row);
                });
                
                // Show container
                highscoreContainer.classList.add('show');
            }
            
            // Event Listeners for highscore system
            saveScoreButton.addEventListener('click', function() {
                const playerName = nameInput.value.trim();
                highscoreManager.addHighscore(playerName, currentScore);
                nameInputContainer.style.display = 'none';
                displayHighscores();
            });
            
            viewHighscoresButton.addEventListener('click', function() {
                displayHighscores();
            });
            
            closeHighscoresButton.addEventListener('click', function() {
                highscoreContainer.classList.remove('show');
            });
            
            exportHighscoresButton.addEventListener('click', function() {
                exportHighscoresToFile(highscoreManager, 'highscore.csv');
            });
            
            importHighscoresButton.addEventListener('click', function() {
                importFileInput.click();
            });
            
            importFileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    importHighscoresFromFile(e.target.files[0], highscoreManager, function(count) {
                        alert(`Imported ${count} highscores`);
                        displayHighscores();
                    });
                }
            });
            
            // Handle "Enter" key in name input to save score
            nameInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    saveScoreButton.click();
                }
            });

            // Event handlers
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onKeyDown(event) {
                if (gameOver) return;

                switch (event.keyCode) {
                    case 87: // W
                        movement.forward = true;
                        break;
                    case 83: // S
                        movement.backward = true;
                        break;
                    case 65: // A
                        movement.left = true;
                        break;
                    case 68: // D
                        movement.right = true;
                        break;
                    case 32: // Space
                        if (canJump) {
                            movement.jump = true;
                        }
                        break;
                    case 82: // R
                        reload();
                        break;
                    case 70: // F
                        if (!isMeleeCooldown) {
                            performMeleeAttack();
                        }
                        break;
                    case 81: // Q - Ultimate Ability
                      if (canUseUltimate) {
                        performUltimate();
                      }
                      break;
                    case 27: // ESC key to pause
                        if (isGameActive && !gameOver) {
                            controls.unlock();
                        }
                        break;
                }
            }

            function onKeyUp(event) {
                if (gameOver) return;
                switch (event.keyCode) {
                    case 87: // W
                        movement.forward = false;
                        break;
                    case 83: // S
                        movement.backward = false;
                        break;
                    case 65: // A
                        movement.left = false;
                        break;
                    case 68: // D
                        movement.right = false;
                        break;
                    case 32: // Space
                        movement.jump = false;
                        break;
                }
            }

          function onMouseDown(event) {
            if (gameOver || !isGameActive || isReloading) return;
            
            if (event.button === 0 && config.ammo > 0) { // Left mouse button
                // Get direction from camera's facing direction
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(camera.quaternion);
                
                // Spawn bullet slightly in front of the camera to prevent collisions
                const bulletSpawnOffset = 0.5;
                const bulletPosition = new THREE.Vector3(
                    camera.position.x + direction.x * bulletSpawnOffset,
                    camera.position.y + direction.y * bulletSpawnOffset,
                    camera.position.z + direction.z * bulletSpawnOffset
                );
                
                const bullet = createBullet(
                    bulletPosition.x,
                    bulletPosition.y,
                    bulletPosition.z,
                    direction
                );
                bullets.push(bullet);
                scene.add(bullet.mesh);
                playSound(sounds.shoot);
                config.ammo--;
                ammoDisplay.textContent = config.ammo;
                maxAmmoDisplay.textContent = config.maxAmmo;
                
                // Auto-reload when empty
                if (config.ammo <= 0 && !isReloading) {
                    reload();
                }
            }
          }

          function onMouseUp(event) {
            if (gameOver) return;
          }

            function updatePlayer(delta) {
                if (!playerBody) return;

                // Movement direction based on keys
                const moveDirection = new THREE.Vector3();
                if (movement.forward) moveDirection.z -= 1;
                if (movement.backward) moveDirection.z += 1;
                if (movement.left) moveDirection.x -= 1;
                if (movement.right) moveDirection.x += 1;

                // Only normalize if we're moving
                if (moveDirection.length() > 0) {
                    moveDirection.normalize();
                }

                // Convert to camera-relative direction
                const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                
                // Project movement onto horizontal plane
                cameraDirection.y = 0;
                cameraRight.y = 0;
                cameraDirection.normalize();
                cameraRight.normalize();
                
                // Calculate movement vector in camera space
                const movementVector = new THREE.Vector3();
                movementVector.addScaledVector(cameraDirection, -moveDirection.z);
                movementVector.addScaledVector(cameraRight, moveDirection.x);
                
                // Acceleration and maximum speed
                const acceleration = 30.0 * delta;
                const maxSpeed = config.playerSpeed;
                const friction = 5.0 * delta;
                
                // Current velocity (only horizontal components)
                const currentVelocity = new THREE.Vector3(playerBody.velocity.x, 0, playerBody.velocity.z);
                
                // Apply acceleration if moving
                if (movementVector.length() > 0) {
                    // Target velocity based on input
                    const targetVelocity = movementVector.clone().multiplyScalar(maxSpeed);
                    
                    // Accelerate towards target velocity
                    currentVelocity.lerp(targetVelocity, acceleration);
                } else {
                    // Apply friction when no movement input
                    const speed = currentVelocity.length();
                    if (speed > 0) {
                        const decelerationFactor = Math.max(0, 1 - friction);
                        currentVelocity.multiplyScalar(decelerationFactor);
                    }
                }
                
                // Apply calculated velocity to physics body
                playerBody.velocity.x = currentVelocity.x;
                playerBody.velocity.z = currentVelocity.z;
                
                // Preserve y-velocity (for jumping/falling)
                playerBody.velocity.y = Math.max(playerBody.velocity.y, -20); // Terminal velocity
                
                // Sync camera position with physics body
                camera.position.copy(playerBody.position);
            }

            // Handle game exit
            window.addEventListener('beforeunload', function() {
                // Clean up resources
                if (backgroundMusic) {
                    backgroundMusic.pause();
                    backgroundMusic.src = '';
                }
                Object.values(sounds).forEach(sound => {
                  sound.pause();
                  sound.src = '';
                });
            });

            // Perform melee attack
            function performMeleeAttack() {
                isMeleeCooldown = true;
                playSound(sounds.melee);
                
                // Melee attack logic (find closest enemy and damage it)
                let closestEnemy = null;
                let minDistance = Infinity;
                
                for (const enemy of enemies) {
                    if (enemy && enemy.isAlive) {
                        const distance = playerBody.position.distanceTo(enemy.body.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestEnemy = enemy;
                        }
                    }
                }
                
                if (closestEnemy && minDistance < 3) { // Melee range is 3 units
                    damageEnemy(closestEnemy, config.meleeDamage);
                    showHitMarker();
                    
                    // Add ultimate charge on melee hit
                    config.ultimateCharge = Math.min(config.ultimateCharge + 10, config.ultimateChargeMax);
                    updateUltimateUI();
                }
                
                setTimeout(() => {
                    isMeleeCooldown = false;
                }, config.meleeCooldown);
            }
            
            // Perform ultimate ability
            function performUltimate() {
                playSound(sounds.ultimate);
                
                // Ultimate ability: K8s Cluster Bomb
                const explosionCenter = new THREE.Vector3(
                    playerBody.position.x, 
                    playerBody.position.y, 
                    playerBody.position.z
                );

                // Find enemies within radius
                for (const enemy of enemies) {
                   if (enemy && enemy.isAlive && enemy.mesh) {
                     const distance = explosionCenter.distanceTo(enemy.mesh.position);
                     if (distance < config.ultimateRadius) {
                       damageEnemy(enemy, config.ultimateDamage);
                     }
                   }
                }
                
                // Visual effect (explosion)
                const explosionGeometry = new THREE.SphereGeometry(config.ultimateRadius, 32, 32);
                const explosionMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    transparent: true, 
                    opacity: 1.0 
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(explosionCenter);
                scene.add(explosion);

                // Add light to explosion
                const explosionLight = new THREE.PointLight(0xffaa00, 2, config.ultimateRadius * 2);
                explosionLight.position.copy(explosionCenter);
                scene.add(explosionLight);

                // Expand and fade explosion
                let explosionScale = 1;
                const expandInterval = setInterval(() => {
                    explosionScale += 0.5;
                    explosion.scale.set(explosionScale, explosionScale, explosionScale);
                    explosionMaterial.opacity -= 0.05;
                    
                    if (explosionScale > 5 || explosionMaterial.opacity <= 0) {
                        clearInterval(expandInterval);
                        scene.remove(explosion);
                        scene.remove(explosionLight);
                    }
                }, 20);

                config.ultimateCharge = 0;
                updateUltimateUI();
                canUseUltimate = false;
            }

            // Reload function
            function reload() {
                if (isReloading || config.ammo >= config.maxAmmo) return;
                
                isReloading = true;
                playSound(sounds.reload);
                
                // Show reload status
                ammoDisplay.textContent = "Reloading...";
                
                setTimeout(() => {
                    config.ammo = config.maxAmmo;
                    ammoDisplay.textContent = config.ammo;
                    isReloading = false;
                }, config.reloadTime);
            }

            // Function to handle game over
            function handleGameOver() {
                gameOver = true;
                isGameActive = false;
                controls.unlock();
                backgroundMusic.pause();
                playSound(sounds.gameOver);
                
                // Set current score
                currentScore = config.score;
                finalScore.textContent = 'Score: ' + currentScore;
                
                // Check if it's a high score
                if (highscoreManager.isHighscore(currentScore)) {
                    nameInputContainer.style.display = 'block';
                    nameInput.focus(); // Focus the input field
                    nameInput.value = localStorage.getItem('playerName') || ''; // Pre-fill with last used name
                } else {
                    nameInputContainer.style.display = 'none';
                }
                
                gameOverScreen.style.display = 'flex';
            }

            // Animation loop for the game
            function animate() {
                if (!isGameActive) return;
                
                // Request next frame first to ensure loop continues even if there's an error
                requestAnimationFrame(animate);
                
                try {
                    const now = performance.now();
                    const delta = Math.min((now - lastTime) / 1000, 0.1); // Cap delta time to prevent huge jumps
                    lastTime = now;
                    
                    // Update physics
                    world.step(1/60);
                    
                    // Update player movement
                    if (movement.jump && canJump) {
                        playerBody.velocity.y = config.jumpForce;
                        canJump = false;
                    }
                    
                    updatePlayer(delta);
                    
                    // Update enemies safely
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        // Skip if index is invalid
                        if (i >= enemies.length) continue;
                        
                        const enemy = enemies[i];
                        if (!enemy || !enemy.isAlive || !enemy.body || !enemy.mesh) {
                            if (enemy) removeEnemy(enemy);
                            continue;
                        }
                        
                        // Update enemy position from physics body
                        enemy.mesh.position.copy(enemy.body.position);
                        
                        // Move enemy towards player
                        const direction = new THREE.Vector3();
                        direction.subVectors(playerBody.position, enemy.body.position);
                        direction.y = 0; // Keep movement on the xz plane
                        direction.normalize();
                        
                        // Apply custom enemy behavior if available
                        if (enemy.type && enemy.type.update) {
                            try {
                                enemy.type.update(enemy, delta);
                            } catch (e) {
                                console.error("Error in enemy update:", e);
                            }
                        } else {
                            // Default behavior
                            enemy.body.velocity.x = direction.x * enemy.speed;
                            enemy.body.velocity.z = direction.z * enemy.speed;
                        }
                        
                        // Check if enemy is close enough to damage player
                        const distance = playerBody.position.distanceTo(enemy.body.position);
                        if (distance < 2) { // If enemy is within 2 units
                            // Apply damage to player (with cooldown)
                            if (now - (enemy.lastAttack || 0) > 1000) { // Attack once per second
                                config.playerHealth -= enemy.damage;
                                healthDisplay.textContent = config.playerHealth;
                                healthFill.style.width = config.playerHealth + '%';
                                enemy.lastAttack = now;
                                playSound(sounds.playerHit);
                                
                                if (config.playerHealth <= 0) {
                                    handleGameOver();
                                    return;
                                }
                            }
                        }
                    }
                    
                    // Periodically spawn enemies if below limit
                    if (enemies.length < config.maxEnemies) {
                        if (Math.random() < 0.005 + (0.002 * config.wave)) { // Increased spawn chance in later waves
                            try {
                                spawnEnemy();
                            } catch (e) {
                                console.error("Error spawning enemy in animate:", e);
                            }
                        }
                    }
                    
                    // Handle bullets safely
                    for (let i = bullets.length - 1; i >= 0; i--) {
                        // Skip if index is invalid
                        if (i >= bullets.length) continue;
                        
                        const bullet = bullets[i];
                        if (!bullet || !bullet.isAlive || !bullet.body || !bullet.mesh) {
                            if (bullet) removeBullet(bullet);
                            continue;
                        }
                        
                        // Update bullet position
                        bullet.mesh.position.copy(bullet.body.position);
                        
                        // Check for collisions with enemies
                        let hitEnemy = false;
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            // Skip if index is invalid
                            if (j >= enemies.length) continue;
                            
                            const enemy = enemies[j];
                            if (!enemy || !enemy.isAlive || !enemy.body) continue;
                            
                            const distance = bullet.body.position.distanceTo(enemy.body.position);
                            if (distance < 1) { // If bullet hits enemy
                                try {
                                    damageEnemy(enemy, config.bulletDamage);
                                    bullet.isAlive = false;
                                    hitEnemy = true;
                                    showHitMarker();
                                    // Add ultimate charge on hit
                                    config.ultimateCharge = Math.min(config.ultimateCharge + 5, config.ultimateChargeMax);
                                    updateUltimateUI();
                                } catch (e) {
                                    console.error("Error handling bullet collision:", e);
                                }
                                break;
                            }
                        }
                        
                        // Remove bullets that have exceeded their lifetime
                        if (!bullet.isAlive || hitEnemy || Date.now() - bullet.created > config.bulletLifetime * 1000) {
                            removeBullet(bullet);
                        }
                    }
                    
                    // Check for player-powerup collisions
                    for (let i = powerUps.length - 1; i >= 0; i--) {
                        if (i >= powerUps.length) continue;
                        try {
                            if (powerUps[i]) {
                                handlePowerUpCollision(playerBody, powerUps[i]);
                            }
                        } catch (e) {
                            console.error("Error handling powerup collision:", e);
                        }
                    }
                    
                    // Memory management - clear excessive bullets
                    if (bullets.length > 50) {
                        for (let i = 0; i < bullets.length - 50; i++) {
                            removeBullet(bullets[i]);
                        }
                    }
                    
                    // Render scene
                    renderer.render(scene, camera);
                    
                    // Update FPS counter
                    updateFPS();
                } catch (e) {
                    console.error("Error in animation loop:", e);
                }
            }
            
            // Function to show hit marker
            function showHitMarker() {
                hitMarker.style.display = 'block';
                setTimeout(() => {
                    hitMarker.style.display = 'none';
                }, 100);
            }

            // Function to create enemy mesh
            function createEnemyMesh(color, scale) {
                const geometry = new THREE.SphereGeometry(0.5 * scale, 8, 8);
                const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.9, metalness: 0.1 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            // Function to create enemy physics body
            function createEnemyPhysicsBody(x, y, z, scale) {
                const shape = new CANNON.Sphere(0.5 * scale);
                const body = new CANNON.Body({
                    mass: 10 * scale,
                    position: new CANNON.Vec3(x, y, z),
                    linearDamping: 0.9
                });
                body.addShape(shape);
                return body;
            }

            // Function to remove enemy
            function removeEnemy(enemy) {
                if (!enemy) return;
                
                try {
                    // Remove from scene
                    if (enemy.mesh) {
                        scene.remove(enemy.mesh);
                    }
                    
                    // Remove from physics world
                    if (enemy.body) {
                        enemy.body.position.set(0, -1000, 0); // Move far away before removal
                        world.removeBody(enemy.body);
                    }
                    
                    // Remove from array
                    const index = enemies.indexOf(enemy);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                    
                    config.enemyCount = Math.max(0, config.enemyCount - 1);
                } catch (e) {
                    console.error("Error removing enemy:", e);
                }
            }

            // Function to deal damage to enemy
            function damageEnemy(enemy, damage) {
                if (!enemy || !enemy.isAlive) return;
                
                // Apply damage
                enemy.health -= damage;
                
                if (enemy.health <= 0) {
                    enemy.isAlive = false;
                    config.score += enemy.type.scoreValue;
                    scoreDisplay.textContent = 'Score: ' + config.score;
                    config.enemiesKilled++;
                    
                    // Execute onDeath effects if any
                    if (enemy.type.onDeath) {
                        try {
                            enemy.type.onDeath(enemy);
                        } catch (e) {
                            console.error("Error in enemy death effect:", e);
                        }
                    }
                    
                    playSound(sounds.enemyDie);
                    removeEnemy(enemy);
                    
                    // Wave management
                    config.killsPerWave--;
                    
                    if (config.killsPerWave <= 0) {
                        // Advance to next wave
                        config.wave++;
                        waveInfo.textContent = 'Wave: ' + config.wave;
                        
                        // Reset kills needed for next wave with scaling difficulty
                        config.killsPerWave = 5 + (5 * config.wave); // Increase kills per wave
                        
                        // Increase enemy limits and spawn new wave
                        config.maxEnemies = Math.min(10 + (config.wave * 2), 30); // Cap at 30 max enemies
                        
                        // Clear any stuck enemies (safety measure)
                        if (enemies.length > config.maxEnemies / 2) {
                            while (enemies.length > config.maxEnemies / 2) {
                                removeEnemy(enemies[0]);
                            }
                        }
                        
                        // Spawn new wave with slight delay
                        setTimeout(spawnEnemyWave, 1000);
                        
                        console.log("Starting Wave " + config.wave + " - Kills needed: " + config.killsPerWave + " - Max enemies: " + config.maxEnemies);
                    }
                }
            }

            // Initialize the game environment and systems
            function init() {
                // Remove any existing event listeners (prevent duplicates)
                window.removeEventListener('resize', onWindowResize);
                document.removeEventListener('keydown', onKeyDown);
                document.removeEventListener('keyup', onKeyUp);
                document.removeEventListener('mousedown', onMouseDown);
                document.removeEventListener('mouseup', onMouseUp);
                
                if (startButton) {
                    startButton.removeEventListener('click', startGame);
                    startButton.addEventListener('click', startGame);
                }
                
                if (restartButton) {
                    restartButton.removeEventListener('click', restartGame);
                    restartButton.addEventListener('click', restartGame);
                }
                
                // Create server room environment
                createEnvironment();
                
                // Set up event listeners
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mouseup', onMouseUp);
                
                // Set up controls lock change handler
                controls.removeEventListener('lock', null);
                controls.removeEventListener('unlock', null);
                
                controls.addEventListener('lock', function() {
                    if (!gameOver) {
                        isGameActive = true;
                    }
                });
                
                controls.addEventListener('unlock', function() {
                    if (isGameActive && !gameOver) {
                        // Game is paused
                    }
                });
                
                console.log("Game initialized successfully");
            }

            init(); // Call init to set up the game
        });
    </script>
</body>
</html>
