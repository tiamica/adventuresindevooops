<!--  Adventures in DevOOPS: The Code Crusade
// A browser-based FPS with DevOps humor and arcade-style action

// Import libraries via CDN in HTML
// Three.js, PointerLockControls, and cannon.js are required

// HTML Structure (to be included in your HTML file)
/* -->

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventures in DevOOPS: The Code Crusade</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-size: 20px;
            pointer-events: none;
        }
        #startMenu {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffffff;
        }
        #startMenu h1 {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            font-size: 36px;
        }
        #startButton {
            background-color: #0ff;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: all 0.3s;
        }
        #startButton:hover {
            background-color: #00cccc;
            transform: scale(1.05);
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0ff;
            font-size: 18px;
            text-shadow: 0 0 3px #000;
        }
        #ammo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #0ff;
            font-size: 18px;
            text-shadow: 0 0 3px #000;
        }
        #healthBar {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #0ff;
            margin-top: 5px;
        }
        #healthFill {
            height: 100%;
            background: #0ff;
            width: 100%;
            transition: width 0.3s;
        }
        #scoreDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #0ff;
            font-size: 24px;
            text-shadow: 0 0 3px #000;
        }
        #ultimate {
            position: absolute;
            bottom: 60px;
            right: 20px;
            color: #ff0;
            font-size: 18px;
            text-shadow: 0 0 3px #000;
        }
        #ultimateBar {
            width: 150px;
            height: 15px;
            background: #333;
            border: 2px solid #ff0;
            margin-top: 5px;
        }
        #ultimateFill {
            height: 100%;
            background: #ff0;
            width: 0%;
            transition: width 0.3s;
        }
        #gameOver {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffffff;
        }
        #gameOver h1 {
            color: #f00;
            text-shadow: 0 0 5px #f00;
            font-size: 36px;
        }
        #restartButton {
            background-color: #0ff;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid #0ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: #0ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #waveInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-size: 18px;
            text-shadow: 0 0 3px #000;
        }
        #hitMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            color: red;
            font-size: 24px;
            transform: translate(-50%, -50%);
            display: none;
            pointer-events: none;
        }
        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #0ff;
            font-size: 24px;
            z-index: 1000;
        }
        .loading-bar {
            width: 300px;
            height: 20px;
            background: #333;
            border: 2px solid #0ff;
            margin-top: 20px;
        }
        .loading-fill {
            height: 100%;
            background: #0ff;
            width: 0%;
            transition: width 0.3s;
        }
        #audioControls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            display: flex;
            align-items: center;
            z-index: 100;
        }
        #audioControls input {
            margin-left: 5px;
        }
        .fps-counter {
            position: absolute;
            top: 50px;
            right: 20px;
            color: #0ff;
            font-size: 14px;
            text-shadow: 0 0 3px #000;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <h1>Loading Game...</h1>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
    </div>
    <div id="startMenu">
        <h1>Adventures in DevOOPS</h1>
        <h2>The Code Crusade</h2>
        <h2>A game from the mind of E.Ihenacho III</h2>
        <button id="startButton">START GAME</button>
        <p>WASD to move, SPACE to jump, CLICK to shoot</p>
        <p>Press R to reload, F for melee attack</p>
        <p>Press Q to use ultimate ability (when available)</p>
        <p>Press ESC to pause the game</p>
    </div>
    <div id="audioControls">
        <label>Audio: <input type="checkbox" id="audioToggle" checked></label>
    </div>
    <div id="gameOver">
        <h1>SYSTEM FAILURE</h1>
        <p id="finalScore">Score: 0</p>
        <button id="restartButton">RESTART</button>
    </div>
    <div class="crosshair"></div>
    <div id="hitMarker">âœ“</div>
    <div id="scoreDisplay">Score: 0</div>
    <div id="waveInfo">Wave: 1</div>
    <div id="hud">
        <div>Server Uptime: <span id="health">100</span>%</div>
        <div id="healthBar"><div id="healthFill"></div></div>
    </div>
    <div id="ammo">
        <div>Bandwidth: <span id="ammoCount">30</span> / <span id="maxAmmo">30</span></div>
    </div>
    <div id="ultimate">
        <div>K8s Cluster Bomb: <span id="ultimateStatus">Charging</span></div>
        <div id="ultimateBar"><div id="ultimateFill"></div></div>
    </div>
    <div class="fps-counter" id="fpsCounter">FPS: 60</div>
    <audio id="backgroundMusic" loop></audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script>
        // Main game code starts here
        document.addEventListener('DOMContentLoaded', function() {
            // Show loading screen
            const loadingScreen = document.getElementById('loadingScreen');
            const loadingFill = document.getElementById('loadingFill');
            const fpsCounter = document.getElementById('fpsCounter');
            const audioToggle = document.getElementById('audioToggle');
            
            let loadingProgress = 0;
            const loadingInterval = setInterval(() => {
                loadingProgress += 5;
                loadingFill.style.width = loadingProgress + '%';
                if (loadingProgress >= 100) {
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }
            }, 100);
            
            // Mute/unmute audio
            let audioEnabled = true;
            
            audioToggle.addEventListener('change', function() {
                audioEnabled = this.checked;
                
                // Update all audio elements
                backgroundMusic.muted = !audioEnabled;
                Object.values(sounds).forEach(sound => {
                    sound.muted = !audioEnabled;
                });
                
                // Save preference
                localStorage.setItem('audioEnabled', audioEnabled);
            });
            
            // Load saved audio preference
            if (localStorage.getItem('audioEnabled') === 'false') {
                audioEnabled = false;
                audioToggle.checked = false;
            }

            // Game configuration
            const config = {
                playerHealth: 100,
                playerSpeed: 300, // Decreased from 500 for better control
                jumpForce: 300,
                gravity: -9.8 * 5,
                ammo: 30,
                maxAmmo: 30,
                reloadTime: 1500, // milliseconds
                meleeCooldown: 600, // milliseconds
                ultimateChargeMax: 100,
                ultimateCharge: 0,
                bulletDamage: 20,
                meleeDamage: 40,
                ultimateDamage: 100,
                ultimateRadius: 20,
                enemySpawnRadius: 40,
                enemyCount: 0,
                maxEnemies: 10,
                wave: 1,
                score: 0,
                killsPerWave: 10,
                enemiesKilled: 0,
                bulletSpeed: 100, // Control bullet speed
                bulletLifetime: 3000 // Bullets live for 3 seconds max
            };

            // Audio configuration
            const sounds = {
                shoot: new Audio('https://assets.mixkit.co/active_storage/sfx/212/212-preview.mp3'),
                reload: new Audio('https://assets.mixkit.co/active_storage/sfx/2020/2020-preview.mp3'),
                melee: new Audio('https://assets.mixkit.co/active_storage/sfx/2018/2018-preview.mp3'),
                hit: new Audio('https://assets.mixkit.co/active_storage/sfx/235/235-preview.mp3'),
                enemyDie: new Audio('https://assets.mixkit.co/active_storage/sfx/156/156-preview.mp3'),
                playerHit: new Audio('https://assets.mixkit.co/active_storage/sfx/209/209-preview.mp3'),
                ultimate: new Audio('https://assets.mixkit.co/active_storage/sfx/557/557-preview.mp3'),
                powerup: new Audio('https://assets.mixkit.co/active_storage/sfx/270/270-preview.mp3'),
                gameOver: new Audio('https://assets.mixkit.co/active_storage/sfx/217/217-preview.mp3')
            };

            // Background music 
            const backgroundMusic = document.getElementById('backgroundMusic');
            backgroundMusic.src = "DarkVibes.mp3"; // Placeholder URL, replace with your music file
            backgroundMusic.volume = 0.4;
            
            // Handle audio loading errors
            backgroundMusic.addEventListener('error', function() {
                console.warn("Error loading background music. Using fallback.");
                this.src = "https://assets.mixkit.co/active_storage/sfx/218/218-preview.mp3"; // Fallback soundtrack
            });

            // Set up volume for sound effects and add error handling
            Object.values(sounds).forEach(sound => {
                sound.volume = 0.3;
                sound.addEventListener('error', function() {
                    console.warn("Error loading sound effect:", this.src);
                });
            });

            // Initialize Three.js scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Dark blue background
            scene.fog = new THREE.Fog(0x050510, 10, 100);

            // Set up camera
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);

            // Set up renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Add neon lights for atmosphere
            const bluePointLight = new THREE.PointLight(0x00ffff, 1, 20);
            bluePointLight.position.set(10, 5, 10);
            scene.add(bluePointLight);

            const purplePointLight = new THREE.PointLight(0xff00ff, 1, 20);
            purplePointLight.position.set(-10, 5, -10);
            scene.add(purplePointLight);

            // Set up physics world
            const world = new CANNON.World();
            world.gravity.set(0, config.gravity, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Materials
            const physicsMaterial = new CANNON.Material("groundMaterial");
            const playerPhysicsMaterial = new CANNON.Material("playerMaterial");

            const playerGroundContact = new CANNON.ContactMaterial(
                playerPhysicsMaterial,
                physicsMaterial,
                { friction: 0.5, restitution: 0.3 }
            );
            world.addContactMaterial(playerGroundContact);

            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Floor physics
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({
                mass: 0,
                material: physicsMaterial
            });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(floorBody);

            // Create server room environment
            createEnvironment();

            // Player setup
            const controls = new THREE.PointerLockControls(camera, document.body);
            let playerBody;
            let canJump = false;
            let isReloading = false;
            let isMeleeCooldown = false;
            let canUseUltimate = false;

            // Initialize player physics body
            function initPlayer() {
                const playerShape = new CANNON.Sphere(1);
                playerBody = new CANNON.Body({
                    mass: 5,
                    material: playerPhysicsMaterial,
                    position: new CANNON.Vec3(0, 2, 0),
                    linearDamping: 0.9
                });
                playerBody.addShape(playerShape);
                world.addBody(playerBody);

                // Contact event to detect when player is on ground
                playerBody.addEventListener('collide', function(e) {
                    const contact = e.contact;
                    const normalVelocity = contact.getImpactVelocityAlongNormal();

                    // Check if contact is on the bottom of the player and the normal velocity is significant
                    if (contact.ni.y > 0.5 && normalVelocity < 0) {
                        canJump = true;
                    }
                });
            }

            // Game state
            let isGameActive = false;
            let gameOver = false;
            const enemies = [];
            const bullets = [];
            const powerUps = [];
            const keys = {};
            let lastTime = performance.now();

            // UI elements
            const healthDisplay = document.getElementById('health');
            const healthFill = document.getElementById('healthFill');
            const ammoDisplay = document.getElementById('ammoCount');
            const maxAmmoDisplay = document.getElementById('maxAmmo');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const ultimateStatus = document.getElementById('ultimateStatus');
            const ultimateFill = document.getElementById('ultimateFill');
            const waveInfo = document.getElementById('waveInfo');
            const startMenu = document.getElementById('startMenu');
            const startButton = document.getElementById('startButton');
            const gameOverScreen = document.getElementById('gameOver');
            const restartButton = document.getElementById('restartButton');
            const finalScore = document.getElementById('finalScore');
            const hitMarker = document.getElementById('hitMarker');

            // Movement vectors
            const movement = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                jump: false
            };

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);

            // Controls lock change handler
            controls.addEventListener('lock', function() {
                if (!gameOver) {
                    isGameActive = true;
                }
            });

            controls.addEventListener('unlock', function() {
                if (isGameActive && !gameOver) {
                    // Game is paused
                }
            });

            // Track FPS
            let frameCount = 0;
            let lastFpsUpdate = 0;
            
            function updateFPS() {
                frameCount++;
                const now = performance.now();
                
                if (now - lastFpsUpdate >= 1000) { // Update once per second
                    const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                    fpsCounter.textContent = `FPS: ${fps}`;
                    frameCount = 0;
                    lastFpsUpdate = now;
                }
            }

            // Audio play function with error handling
            function playSound(sound) {
                if (!audioEnabled) return;
                
                try {
                    // Reset sound to beginning if it's already playing
                    sound.currentTime = 0;
                    sound.play().catch(e => {
                        console.warn("Error playing sound:", e);
                    });
                } catch (e) {
                    console.warn("Error playing sound:", e);
                }
            }
            
            // Background music play function
            function playMusic() {
                if (!audioEnabled) return;
                
                try {
                    backgroundMusic.play().catch(e => {
                        console.warn("Unable to autoplay music. User interaction needed:", e);
                    });
                } catch (e) {
                    console.warn("Error playing music:", e);
                }
            }

            // Start the game
            function startGame() {
                startMenu.style.display = 'none';
                initPlayer();
                controls.lock();
                playMusic();
                isGameActive = true;
                gameOver = false;
                spawnServerRacks();
                spawnEnemyWave(); // Spawn initial wave
                animate();
            }

            // Restart the game
            function restartGame() {
                // Reset game configuration
                config.playerHealth = 100;
                config.ammo = config.maxAmmo;
                config.ultimateCharge = 0;
                config.wave = 1;
                config.score = 0;
                config.enemiesKilled = 0;

                // Update UI
                healthDisplay.textContent = config.playerHealth;
                healthFill.style.width = config.playerHealth + '%';
                ammoDisplay.textContent = config.ammo;
                scoreDisplay.textContent = 'Score: ' + config.score;
                ultimateStatus.textContent = 'Charging';
                ultimateFill.style.width = '0%';
                waveInfo.textContent = 'Wave: ' + config.wave;

                // Reset player position
                playerBody.position.set(0, 2, 0);
                playerBody.velocity.set(0, 0, 0);

                // Clear all enemies, bullets, and powerups
                while (enemies.length > 0) {
                    removeEnemy(enemies[0]);
                }

                while (bullets.length > 0) {
                    removeBullet(bullets[0]);
                }

                while (powerUps.length > 0) {
                    removePowerUp(powerUps[0]);
                }

                // Hide game over screen
                gameOverScreen.style.display = 'none';

                // Lock controls and activate game
                controls.lock();
                isGameActive = true;
                gameOver = false;

                // Restart background music
                backgroundMusic.currentTime = 0;
                try {
                    backgroundMusic.play().catch(e => {
                        console.warn("Error restarting music:", e);
                    });
                } catch (e) {
                    console.warn("Error restarting music:", e);
                }
            }

            // Create environment (server room with server racks)
            function createEnvironment() {
                // Create server room walls
                const wallMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333344,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const gridHelper = new THREE.GridHelper(100, 50, 0x0088ff, 0x0044aa);
                scene.add(gridHelper);

                // Add walls
                const wallGeometry = new THREE.BoxGeometry(100, 10, 1);
                const walls = [
                    { position: [0, 5, 50], rotation: [0, 0, 0] },
                    { position: [0, 5, -50], rotation: [0, 0, 0] },
                    { position: [50, 5, 0], rotation: [0, Math.PI / 2, 0] },
                    { position: [-50, 5, 0], rotation: [0, Math.PI / 2, 0] }
                ];
                walls.forEach(wall => {
                    const mesh = new THREE.Mesh(wallGeometry, wallMaterial);
                    mesh.position.set(...wall.position);
                    mesh.rotation.set(...wall.rotation);
                    scene.add(mesh);
                    // Add physics body for wall
                    const wallShape = new CANNON.Box(new CANNON.Vec3(50, 5, 0.5));
                    const wallBody = new CANNON.Body({ mass: 0, material: physicsMaterial });
                    wallBody.addShape(wallShape);
                    wallBody.position.set(...wall.position);
                    wallBody.quaternion.setFromEuler(...wall.rotation);
                    world.addBody(wallBody);
                });

                // Add some cool neon lights to the ceiling
                const ceilingLights = [];
                for (let i = -40; i <= 40; i += 20) {
                    for (let j = -40; j <= 40; j += 20) {
                        const light = new THREE.PointLight(0x00ccff, 0.7, 15);
                        light.position.set(i, 9, j);
                        scene.add(light);
                        ceilingLights.push(light);
                        // Add light fixture mesh
                        const lightFixtureGeometry = new THREE.BoxGeometry(1, 0.2, 1);
                        const lightFixtureMaterial = new THREE.MeshStandardMaterial({ color: 0x00ccff, emissive: 0x00ccff, emissiveIntensity: 0.5 });
                        const lightFixture = new THREE.Mesh(lightFixtureGeometry, lightFixtureMaterial);
                        lightFixture.position.set(i, 9, j);
                        scene.add(lightFixture);
                    }
                }
            }

            // Spawn server racks as obstacles
            function spawnServerRacks() {
                const rackGeometry = new THREE.BoxGeometry(2, 4, 6);
                const rackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.7 });
                const rackPositions = [
                    { x: 10, z: 10 }, { x: -10, z: 10 }, { x: 10, z: -10 }, { x: -10, z: -10 },
                    { x: 20, z: 20 }, { x: -20, z: 20 }, { x: 20, z: -20 }, { x: -20, z: -20 },
                    { x: 0, z: 20 }, { x: 0, z: -20 }, { x: 20, z: 0 }, { x: -20, z: 0 }
                ];
                rackPositions.forEach(position => {
                    // Create a server rack with blinking lights
                    const rack = new THREE.Group();
                    // Main rack
                    const mainRack = new THREE.Mesh(rackGeometry, rackMaterial);
                    rack.add(mainRack);
                    // Add blinking lights
                    for (let i = 0; i < 5; i++) {
                        const lightGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                        const lightColor = Math.random() > 0.5 ? 0x00ff00 : 0xff0000;
                        const lightMaterial = new THREE.MeshBasicMaterial({ color: lightColor, emissive: lightColor, emissiveIntensity: 1 });
                        const light = new THREE.Mesh(lightGeometry, lightMaterial);
                        light.position.set(0.9, i * 0.7 - 1.5, -2.5);
                        rack.add(light);
                        // Add point light for glow effect
                        const pointLight = new THREE.PointLight(lightColor, 0.5, 3);
                        pointLight.position.copy(light.position);
                        rack.add(pointLight);
                    }
                    // Position the rack
                    rack.position.set(position.x, 2, position.z);
                    // Random rotation
                    rack.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(rack);
                    // Add physics body for the rack
                    const rackShape = new CANNON.Box(new CANNON.Vec3(1, 2, 3));
                    const rackBody = new CANNON.Body({ mass: 0, material: physicsMaterial });
                    rackBody.addShape(rackShape);
                    rackBody.position.set(position.x, 2, position.z);
                    rackBody.quaternion.setFromEuler(0, rack.rotation.y, 0);
                    world.addBody(rackBody);
                });
            }

            // Enemy types
            const enemyTypes = [
                {
                    name: "Buffer Overflow Beetle",
                    health: 40,
                    speed: 3,
                    damage: 10,
                    color: 0xff5500,
                    scale: 1,
                    scoreValue: 100,
                    onDeath: function(enemy) {
                        // Spawn smaller bugs on death
                        if (enemy.scale === 1) {
                            for (let i = 0; i < 2; i++) {
                                spawnSmallBug(enemy.mesh.position.x, enemy.mesh.position.z);
                            }
                        }
                    }
                },
                {
                    name: "SQL Injection Slug",
                    health: 30,
                    speed: 2,
                    damage: 5,
                    color: 0x00ff00,
                    scale: 0.8,
                    scoreValue: 150,
                    update: function(enemy, delta) {
                        // Leave toxic trail
                        if (Math.random() < 0.05) {
                            createToxicTrail(enemy.mesh.position.x, enemy.mesh.position.z);
                        }
                    }
                },
                {
                    name: "404 Zombie",
                    health: 25,
                    speed: 2.5,
                    damage: 8,
                    color: 0x888888,
                    scale: 1.2,
                    scoreValue: 120
                },
                {
                    name: "DDoS Droid",
                    health: 60,
                    speed: 4,
                    damage: 15,
                    color: 0x00ffff,
                    scale: 1.5,
                    scoreValue: 200,
                    attackPattern: "charge", // Special attack pattern
                    chargeSpeed: 8,
                    isCharging: false,
                    chargeTarget: null,
                    chargeTimer: 0,
                    onDeath: function(enemy) {
                      // Drop a powerup on death
                      spawnPowerUp(enemy.mesh.position.x, enemy.mesh.position.z);
                    },
                    update: function(enemy, delta) {
                        if (this.isCharging) {
                            this.chargeTimer -= delta;
                            if (this.chargeTimer <= 0) {
                                this.isCharging = false;
                                this.chargeTimer = 0;
                                this.chargeTarget = null;
                                this.speed = this.speed / 2; // Revert to normal speed
                            }
                            // Move towards player
                            if (this.chargeTarget) {
                                const direction = new THREE.Vector3();
                                direction.subVectors(playerBody.position, enemy.mesh.position);
                                direction.normalize();
                                enemy.body.velocity.x = direction.x * this.chargeSpeed;
                                enemy.body.velocity.z = direction.z * this.chargeSpeed;
                            }
                        } else {
                            if (Math.random() < 0.02) { // 2% chance per frame to start charging
                                this.isCharging = true;
                                this.chargeTimer = 2000; // Charge for 2 seconds
                                this.chargeTarget = playerBody.position.clone();
                                this.speed = this.chargeSpeed; // Double speed when charging.
                            }
                        }
                    }
                }
            ];

            // Function to spawn a small bug
            function spawnSmallBug(x, z) {
                const bugType = enemyTypes.find(type => type.name === "Buffer Overflow Beetle");
                if (!bugType) return;

                const enemy = {
                    type: bugType,
                    health: bugType.health * 0.5, // Half health
                    speed: bugType.speed * 1.5, // 1.5x speed
                    damage: bugType.damage * 0.5, // Half damage
                    mesh: createEnemyMesh(bugType.color, 0.5), // Half size
                    body: createEnemyPhysicsBody(x, 1, z, 0.5),
                    scale: 0.5,
                    isAlive: true
                };
                enemy.mesh.position.set(x, 1, z);
                scene.add(enemy.mesh);
                world.addBody(enemy.body);
                enemies.push(enemy);
                config.enemyCount++;
            }

            // Function to create a toxic trail
            function createToxicTrail(x, z) {
                const trailGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const trailMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 });
                const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                trailMesh.position.set(x, 0.1, z);
                scene.add(trailMesh);

                // Add to an array for disposal later
                setTimeout(() => {
                    scene.remove(trailMesh);
                }, 2000); // Remove after 2 seconds
            }

            // Function to spawn an enemy
          function spawnEnemy() {
            if (config.enemyCount >= config.maxEnemies) return;

            const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            const angle = Math.random() * Math.PI * 2;
            const x = playerBody.position.x + Math.cos(angle) * config.enemySpawnRadius;
            const z = playerBody.position.z + Math.sin(angle) * config.enemySpawnRadius;

            // Check if the enemy would spawn inside a server rack
            let isInsideRack = false;
            for (const rack of scene.children) {
                if (rack.type === 'Group') { // Server racks are groups
                    const rackX = rack.position.x;
                    const rackZ = rack.position.z;
                    const distance = Math.sqrt(Math.pow(x - rackX, 2) + Math.pow(z - rackZ, 2));
                    if (distance < 5) { // If within 5 units of a rack
                        isInsideRack = true;
                        break;
                    }
                }
            }

            if (isInsideRack) {
                // Try spawning again, recursively, up to a maximum number of attempts
                spawnEnemy(); // Recursive call
                return; // Important: Exit the current spawn attempt
            }

            const enemy = {
                type: enemyType,
                health: enemyType.health,
                speed: enemyType.speed,
                damage: enemyType.damage,
                mesh: createEnemyMesh(enemyType.color, enemyType.scale),
                body: createEnemyPhysicsBody(x, 1, z, enemyType.scale),
                scale: enemyType.scale,
                isAlive: true
            };
            enemy.mesh.position.set(x, 1, z);
            scene.add(enemy.mesh);
            world.addBody(enemy.body);
            enemies.push(enemy);
            config.enemyCount++;
        }

            // Function to create enemy mesh
            function createEnemyMesh(color, scale) {
                const geometry = new THREE.SphereGeometry(0.5 * scale, 8, 8);
                const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.9, metalness: 0.1 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            // Function to create enemy physics body
            function createEnemyPhysicsBody(x, y, z, scale) {
                const shape = new CANNON.Sphere(0.5 * scale);
                const body = new CANNON.Body({
                    mass: 10 * scale,
                    position: new CANNON.Vec3(x, y, z),
                    linearDamping: 0.9
                });
                body.addShape(shape);
                return body;
            }

            // Function to remove enemy
            function removeEnemy(enemy) {
                if (!enemy) return;
                if (enemy.mesh) {
                  scene.remove(enemy.mesh);
                }
                if (enemy.body) {
                  world.removeBody(enemy.body);
                }
                const index = enemies.indexOf(enemy);
                if (index > -1) {
                    enemies.splice(index, 1);
                }
                config.enemyCount--;
            }

            // Function to deal damage to enemy
            function damageEnemy(enemy, damage) {
                if (!enemy.isAlive) return;
                enemy.health -= damage;
                if (enemy.health <= 0) {
                    enemy.isAlive = false;
                    config.score += enemy.type.scoreValue;
                    scoreDisplay.textContent = 'Score: ' + config.score;
                    config.killsPerWave--;
                    config.enemiesKilled++;
                    if (enemy.type.onDeath) {
                        enemy.type.onDeath(enemy);
                    }
                    playSound(sounds.enemyDie);
                    removeEnemy(enemy);
                    if (config.killsPerWave <= 0) {
                        config.wave++;
                        waveInfo.textContent = 'Wave: ' + config.wave;
                        config.killsPerWave = 10 * config.wave; // Increase kills per wave
                        config.maxEnemies += 5; // Increase max enemies
                        spawnEnemyWave();
                    }
                }
            }

            // Function to spawn a wave of enemies
            function spawnEnemyWave() {
                for (let i = 0; i < 5; i++) { // Spawn 5 enemies per wave initially
                    setTimeout(spawnEnemy, i * 200); // Staggered spawn
                }
            }

            // Bullet logic
            function createBullet(x, y, z, direction) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                
                // Add point light to bullet for glow effect
                const bulletLight = new THREE.PointLight(0xffff00, 0.5, 2);
                mesh.add(bulletLight);
                
                const body = new CANNON.Body({
                    mass: 1,
                    position: new CANNON.Vec3(x, y, z),
                    linearDamping: 0,
                    shape: new CANNON.Sphere(0.1)
                });
                
                body.velocity.set(
                    direction.x * config.bulletSpeed, 
                    direction.y * config.bulletSpeed, 
                    direction.z * config.bulletSpeed
                );
                
                world.addBody(body);
                
                // Set lifetime for bullet to avoid memory leaks
                const bulletObj = { 
                    mesh, 
                    body, 
                    isAlive: true,
                    created: Date.now()
                };
                
                return bulletObj;
            }

            // Function to remove bullet
            function removeBullet(bullet) {
                if (!bullet) return;
                if (bullet.mesh) {
                    scene.remove(bullet.mesh);
                }
                if (bullet.body) {
                    world.removeBody(bullet.body);
                }
                const index = bullets.indexOf(bullet);
                if (index > -1) {
                    bullets.splice(index, 1);
                }
            }

            // Power-up types
            const powerUpTypes = [
                {
                    name: "Health Pack",
                    color: 0x00ff00,
                    onPickup: function(player) {
                        config.playerHealth = Math.min(config.playerHealth + 20, 100);
                        healthDisplay.textContent = config.playerHealth;
                        healthFill.style.width = config.playerHealth + '%';
                        playSound(sounds.powerup);
                    }
                },
                {
                    name: "Ammo Refill",
                    color: 0x00ffff,
                    onPickup: function(player) {
                        config.ammo = config.maxAmmo;
                        ammoDisplay.textContent = config.ammo + ' / ' + config.maxAmmo;
                        playSound(sounds.powerup);
                    }
                },
                {
                  name: "Ultimate Charge",
                  color: 0xffa500, // Orange
                  onPickup: function(player) {
                    config.ultimateCharge = Math.min(config.ultimateCharge + 30, config.ultimateChargeMax); // Give 30% charge
                    updateUltimateUI();
                    playSound(sounds.powerup);
                  }
                }
            ];

            // Function to spawn a power-up
            function spawnPowerUp(x, z) {
                const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
                const material = new THREE.MeshBasicMaterial({ color: powerUpType.color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, 0.5, z);
                scene.add(mesh);
                const powerUp = {
                    type: powerUpType,
                    mesh: mesh,
                    isAlive: true
                };
                powerUps.push(powerUp);
            }

            // Function to remove power-up
            function removePowerUp(powerUp) {
                if (!powerUp) return;
                scene.remove(powerUp.mesh);
                const index = powerUps.indexOf(powerUp);
                if (index > -1) {
                    powerUps.splice(index, 1);
                }
            }

            // Function to handle player-powerup collision
            function handlePowerUpCollision(playerBody, powerUp) {
              if (!powerUp.isAlive) return;

              const playerPos = new THREE.Vector3(playerBody.position.x, playerBody.position.y, playerBody.position.z);
              const powerUpPos = powerUp.mesh.position;
              const distance = playerPos.distanceTo(powerUpPos);

              if (distance < 1.5) { // If player is close enough
                  powerUp.type.onPickup(playerBody); // Apply power-up effect
                  removePowerUp(powerUp); // Remove power-up from scene
              }
            }

            // Function to update ultimate UI
            function updateUltimateUI() {
                ultimateFill.style.width = (config.ultimateCharge / config.ultimateChargeMax) * 100 + '%';
                if (config.ultimateCharge >= config.ultimateChargeMax) {
                    canUseUltimate = true;
                    ultimateStatus.textContent = 'READY!';
                } else {
                    canUseUltimate = false;
                    ultimateStatus.textContent = 'Charging';
                }
            }

            // Function to handle game over
            function handleGameOver() {
                gameOver = true;
                isGameActive = false;
                controls.unlock();
                backgroundMusic.pause();
                playSound(sounds.gameOver);
                finalScore.textContent = 'Score: ' + config.score;
                gameOverScreen.style.display = 'flex';
            }

            // Event handlers
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onKeyDown(event) {
                if (gameOver) return;

                switch (event.keyCode) {
                    case 87: // W
                        movement.forward = true;
                        break;
                    case 83: // S
                        movement.backward = true;
                        break;
                    case 65: // A
                        movement.left = true;
                        break;
                    case 68: // D
                        movement.right = true;
                        break;
                    case 32: // Space
                        if (canJump) {
                            movement.jump = true;
                        }
                        break;
                    case 82: // R
                        reload();
                        break;
                    case 70: // F
                        if (!isMeleeCooldown) {
                            performMeleeAttack();
                        }
                        break;
                    case 81: // Q - Ultimate Ability
                      if (canUseUltimate) {
                        performUltimate();
                      }
                      break;
                    case 27: // ESC key to pause
                        if (isGameActive && !gameOver) {
                            controls.unlock();
                        }
                        break;
                }
            }

            function onKeyUp(event) {
                if (gameOver) return;
                switch (event.keyCode) {
                    case 87: // W
                        movement.forward = false;
                        break;
                    case 83: // S
                        movement.backward = false;
                        break;
                    case 65: // A
                        movement.left = false;
                        break;
                    case 68: // D
                        movement.right = false;
                        break;
                    case 32: // Space
                        movement.jump = false;
                        break;
                }
            }

          function onMouseDown(event) {
            if (gameOver || !isGameActive || isReloading) return;
            
            if (event.button === 0 && config.ammo > 0) { // Left mouse button
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(camera.quaternion);
                
                const bullet = createBullet(
                    camera.position.x,
                    camera.position.y,
                    camera.position.z,
                    direction
                );
                bullets.push(bullet);
                scene.add(bullet.mesh);
                playSound(sounds.shoot);
                config.ammo--;
                ammoDisplay.textContent = config.ammo;
                maxAmmoDisplay.textContent = config.maxAmmo;
                
                // Auto-reload when empty
                if (config.ammo <= 0 && !isReloading) {
                    reload();
                }
            }
          }

          function onMouseUp(event) {
            if (gameOver) return;
          }

            function updatePlayer(delta) {
                if (!playerBody) return;

                const velocity = new THREE.Vector3();
                if (movement.forward) velocity.z -= 1;
                if (movement.backward) velocity.z += 1;
                if (movement.left) velocity.x -= 1;
                if (movement.right) velocity.x += 1;
                velocity.normalize();

                const scaledSpeed = config.playerSpeed * delta;
                playerBody.velocity.x = velocity.x * scaledSpeed;
                playerBody.velocity.z = velocity.z * scaledSpeed;

                if (movement.jump && canJump) {
                    playerBody.velocity.y = config.jumpForce;
                    canJump = false;
                }

                // Update camera position
                camera.position.set(
                    playerBody.position.x,
                    playerBody.position.y + 1.5, // Camera is slightly above the player
                    playerBody.position.z
                );
                controls.getObject().position.copy(camera.position);
            }

            function updateBullets(delta) {
                const now = Date.now();
                
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    if (!bullet || !bullet.isAlive) {
                        removeBullet(bullet);
                        continue;
                    }
                    
                    // Update bullet position
                    if (bullet.mesh && bullet.body) {
                        bullet.mesh.position.copy(bullet.body.position);
                    }
                    
                    // Check bullet lifetime
                    if (now - bullet.created > config.bulletLifetime) {
                        bullet.isAlive = false;
                        removeBullet(bullet);
                        continue;
                    }
                    
                    // Check for collision with enemies
                    for (const enemy of enemies) {
                        if (enemy && enemy.isAlive && enemy.mesh) {
                            const distance = bullet.mesh.position.distanceTo(enemy.mesh.position);
                            if (distance < 0.8) { // Adjust as needed
                                // Add ultimate charge on hit
                                config.ultimateCharge = Math.min(config.ultimateCharge + 5, config.ultimateChargeMax);
                                updateUltimateUI();
                                
                                damageEnemy(enemy, config.bulletDamage);
                                bullet.isAlive = false;
                                removeBullet(bullet);
                                showHitMarker();
                                break; // Important: Break after handling collision
                            }
                        }
                    }
                    
                    // Remove bullets that go too far
                    if (bullet.mesh && bullet.mesh.position.distanceTo(camera.position) > 100) {
                        bullet.isAlive = false;
                        removeBullet(bullet);
                    }
                }
            }

            function updateEnemies(delta) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (!enemy || !enemy.isAlive) continue;

                    if(enemy.type && enemy.type.update){
                      enemy.type.update(enemy, delta);
                    }

                    if (enemy.mesh && enemy.body) {
                        enemy.mesh.position.copy(enemy.body.position);

                        // Enemy AI: Follow player
                        const direction = new THREE.Vector3();
                        direction.subVectors(playerBody.position, enemy.mesh.position);
                        direction.normalize();
                        enemy.body.velocity.x = direction.x * enemy.speed;
                        enemy.body.velocity.z = direction.z * enemy.speed;

                        // Check for collision with player (for damage)
                        const distance = playerBody.position.distanceTo(enemy.mesh.position);
                        if (distance < 1.5) { // Adjust as needed
                            config.playerHealth -= enemy.damage;
                            healthDisplay.textContent = config.playerHealth;
                            healthFill.style.width = config.playerHealth + '%';
                            try {
                                playSound(sounds.playerHit);
                            } catch (e) {
                                console.warn("Error playing hit sound:", e);
                            }
                            if (config.playerHealth <= 0) {
                                handleGameOver();
                            }
                            // Only damage enemy when hitting it
                            damageEnemy(enemy, 10);
                        }
                    }
                }
            }

          function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
              const powerUp = powerUps[i];
              if (!powerUp.isAlive) continue;
              handlePowerUpCollision(playerBody, powerUp);
            }
          }

            function showHitMarker() {
                hitMarker.style.display = 'block';
                setTimeout(() => {
                    hitMarker.style.display = 'none';
                }, 100); // Hide after 100ms
            }

            function animate() {
                if (!isGameActive) {
                    requestAnimationFrame(animate);
                    return;
                }

                const currentTime = performance.now();
                const delta = Math.min((currentTime - lastTime) / 1000, 0.1); // Cap delta at 0.1 for stability
                lastTime = currentTime;

                updateFPS(); // Update FPS counter
                
                // Physics and game updates
                world.step(delta);
                updatePlayer(delta);
                updateBullets(delta);
                updateEnemies(delta);
                updatePowerUps();

                // Charge ultimate over time
                if (config.ultimateCharge < config.ultimateChargeMax) {
                    config.ultimateCharge += delta * 2; // Charge 2 points per second
                    if (config.ultimateCharge >= config.ultimateChargeMax) {
                        config.ultimateCharge = config.ultimateChargeMax;
                    }
                    updateUltimateUI();
                }

                // Cap enemy count. Adjust timing as needed.
                if (enemies.length < config.maxEnemies && Math.random() < 0.05) {
                    spawnEnemy();
                }

                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }

            // Pre-load sounds
            function preloadSounds() {
                try {
                    Object.values(sounds).forEach(sound => {
                        sound.load();
                    });
                    backgroundMusic.load();
                } catch (e) {
                    console.warn("Error preloading sounds:", e);
                }
            }

            // Start the game setup
            function init() {
                // Set up event listeners
                document.getElementById('startButton').addEventListener('click', startGame);
                document.getElementById('restartButton').addEventListener('click', restartGame);

                // Pre-load sounds
                preloadSounds();

                // Display instructions
                console.log("Game initialized. Click Start to begin!");
            }

            // Handle browser visibility changes
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    // Pause game when tab is not active
                    if (backgroundMusic) {
                        backgroundMusic.pause();
                    }
                } else {
                    // Resume game when tab is active again
                    if (isGameActive && !gameOver && backgroundMusic) {
                        backgroundMusic.play();
                    }
                }
            });

            // Handle game exit
            window.addEventListener('beforeunload', function() {
                // Clean up resources
                if (backgroundMusic) {
                    backgroundMusic.pause();
                    backgroundMusic.src = '';
                }
                Object.values(sounds).forEach(sound => {
                  sound.pause();
                  sound.src = '';
                });
            });

            // Perform melee attack
            function performMeleeAttack() {
                isMeleeCooldown = true;
                playSound(sounds.melee);
                
                // Melee attack logic (find closest enemy and damage it)
                let closestEnemy = null;
                let minDistance = Infinity;
                
                for (const enemy of enemies) {
                    if (enemy && enemy.isAlive) {
                        const distance = playerBody.position.distanceTo(enemy.body.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestEnemy = enemy;
                        }
                    }
                }
                
                if (closestEnemy && minDistance < 3) { // Melee range is 3 units
                    damageEnemy(closestEnemy, config.meleeDamage);
                    showHitMarker();
                    
                    // Add ultimate charge on melee hit
                    config.ultimateCharge = Math.min(config.ultimateCharge + 10, config.ultimateChargeMax);
                    updateUltimateUI();
                }
                
                setTimeout(() => {
                    isMeleeCooldown = false;
                }, config.meleeCooldown);
            }
            
            // Perform ultimate ability
            function performUltimate() {
                playSound(sounds.ultimate);
                
                // Ultimate ability: K8s Cluster Bomb
                const explosionCenter = new THREE.Vector3(
                    playerBody.position.x, 
                    playerBody.position.y, 
                    playerBody.position.z
                );

                // Find enemies within radius
                for (const enemy of enemies) {
                   if (enemy && enemy.isAlive && enemy.mesh) {
                     const distance = explosionCenter.distanceTo(enemy.mesh.position);
                     if (distance < config.ultimateRadius) {
                       damageEnemy(enemy, config.ultimateDamage);
                     }
                   }
                }
                
                // Visual effect (explosion)
                const explosionGeometry = new THREE.SphereGeometry(config.ultimateRadius, 32, 32);
                const explosionMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    transparent: true, 
                    opacity: 1.0 
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(explosionCenter);
                scene.add(explosion);

                // Add light to explosion
                const explosionLight = new THREE.PointLight(0xffaa00, 2, config.ultimateRadius * 2);
                explosionLight.position.copy(explosionCenter);
                scene.add(explosionLight);

                // Expand and fade explosion
                let explosionScale = 1;
                const expandInterval = setInterval(() => {
                    explosionScale += 0.5;
                    explosion.scale.set(explosionScale, explosionScale, explosionScale);
                    explosionMaterial.opacity -= 0.05;
                    
                    if (explosionScale > 5 || explosionMaterial.opacity <= 0) {
                        clearInterval(expandInterval);
                        scene.remove(explosion);
                        scene.remove(explosionLight);
                    }
                }, 20);

                config.ultimateCharge = 0;
                updateUltimateUI();
                canUseUltimate = false;
            }

            // Reload function
            function reload() {
                if (isReloading || config.ammo >= config.maxAmmo) return;
                
                isReloading = true;
                playSound(sounds.reload);
                
                // Show reload status
                ammoDisplay.textContent = "Reloading...";
                
                setTimeout(() => {
                    config.ammo = config.maxAmmo;
                    ammoDisplay.textContent = config.ammo;
                    isReloading = false;
                }, config.reloadTime);
            }

            init(); // Call init to set up the game
        });
    </script>
</body>
</html>
